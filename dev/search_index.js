var documenterSearchIndex = {"docs":
[{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"EditURL = \"https://github.com/FHell/BAC.jl/blob/master/examples/simple_graph_example.jl\"","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"using BAC\n\nusing Random\nusing Plots\nRandom.seed!(42);\nusing GraphPlot\nusing DiffEqFlux\nusing Pipe: @pipe\nusing Statistics","category":"page"},{"location":"generated/simple_graph_example/#Simple-graph-example","page":"Simple graph example","title":"Simple graph example","text":"","category":"section"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"As an example we want to tune a system of 10 nodes with one grid connection point to a specification of 2 nodes.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"Our goal is to find such parameters for the 10-node system that it behaves close enough to a 2-node system under all possible inputs. In this example we start with just 10 possible inputs.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"dim_sys = 10\nbac_10 = BAC.create_graph_example(dim_sys, 3, 0.:0.1:10., 10);\nnothing #hide","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"We can plot the input samples and system layouts. Optimized system is a nonlinear diffusively coupled graph system. Specification is a two node version of the graph.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"plot(0:0.01:10, bac_10.input_sample, c=:gray, alpha=1, legend=false)\nBAC.plot_sys_graph(bac_10)","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"=> Can we make a large graph react like a small graph by tuning the non-linearity at the nodes?","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"p_initial = ones(2*10+dim_sys)","category":"page"},{"location":"generated/simple_graph_example/#Finished-initialization","page":"Simple graph example","title":"Finished initialization","text":"","category":"section"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"bac_10 implements the loss function. We are looking for parameters that minimize it. It can be evaluated directly on a parameter array:","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"l = bac_10(p_initial; abstol=1e-2, reltol=1e-2)","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"Plot callback plots the solutions passed to it. We choose what samples to use for plots, as plotting for all samples makes visual results harder to understand.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"samples = 1:3 # we can choose what samples to use for plots everywhere\nBAC.plot_callback(bac_10, p_initial, l, input_sample=samples)\n\n#losses = zeros(0) # for plotting loss change over the course of optimization","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"Underlying the loss function is the output metric comparing the two trajectories:","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"sol1, sol2 = solve_bl_n(bac_10, 3, p_initial, input_sample=samples)\nbac_10.output_metric(sol1, sol2)\n\n#= We can get all the individual contributions with individual_losses:=#\nil = individual_losses(bac_10, p_initial)\n\n#= Training with 10 samples, low accuracy and relatively large ADAM step size is a way to quickly get a good approximation, that can then be improved by increasing accuracy and number of samples.\n=#\n@time res_10 = DiffEqFlux.sciml_train(\n    p -> bac_10(p; abstol=1e-2, reltol=1e-2),\n    p_initial,\n    DiffEqFlux.ADAM(0.5),\n    maxiters = 5,\n    cb = (p, l) -> plot_callback(bac_10, p, l, input_sample=samples)\n    )\n\nplot_callback(bac_10, res_10.minimizer, l, input_sample = 1:3)\n\n@time res_10 = DiffEqFlux.sciml_train(\n    p -> bac_10(p; abstol=1e-6, reltol=1e-6),\n    res_10.minimizer,\n    DiffEqFlux.ADAM(0.5),\n    maxiters = 20,\n    cb = (p, l) -> plot_callback(bac_10, p, l, input_sample = samples)\n    )\n\n@time res_10 = DiffEqFlux.sciml_train(\n    p -> bac_10(p),\n    res_10.minimizer,\n    DiffEqFlux.ADAM(0.5),\n    maxiters = 20,\n    cb = basic_bac_callback\n    )\n\nplot_callback(bac_10, res_10.minimizer, l; input_sample=samples)","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"After getting a good initial approximation, we can look at the minimizer. Going further makes little sense as we would be overfitting to the small sample.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"res_10.minimizer[1:dim_sys] |> BAC.relu |> println #p_sys\nres_10.minimizer[dim_sys+1:end] |> BAC.relu |> println #p_spec\n\n#= ## Resampling\nWe can check the quality of the resulting minimizer by optimizing the specs only (a much simpler repeated 2d optimization problem)\n=#\np2 = bac_spec_only(bac_10, res_10.minimizer)\nlosses = individual_losses(bac_10, p2)\nmedian(losses)","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"In order to understand how much we were overfitting with respect to the concrete sample, we resample. That is, we generate a new problem with a new sample from the same distribution: This will give us information on the system tuning with a sample different from the one that the tuning was optimized for.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"bac_10_rs = resample(BAC.rand_fourier_input_generator, bac_10);\np3 = bac_spec_only(bac_10_rs, res_10.minimizer)\nlosses_rs = individual_losses(bac_10_rs, p3)\nmedian(losses_rs)","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"The median individual loss has gone up by a factor of 4. This means that the system is somewhat overfit to the initial sample.","category":"page"},{"location":"generated/simple_graph_example/#Larger-number-of-samples","page":"Simple graph example","title":"Larger number of samples","text":"","category":"section"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"We warmed up the optimization with a very small number of samples, we can now initialize a higher sampled optimization using the system parameters found in the lower one:","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"p_100 = ones(2*100+dim_sys)\np_100[1:dim_sys] .= res_10.minimizer[1:dim_sys]\np_100[dim_sys+1:end] .= repeat(res_10.minimizer[dim_sys+1:dim_sys+2], 100)\n\nbac_100 = resample(BAC.rand_fourier_input_generator, bac_10; n = 100);\nnothing #hide","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"Optimizing only the specs is a task linear in the number of samples, the idea is that this will help with warming up the optimization. We can also study the quality of the tuning found by the optimization based on a small number of samples.","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"p_100_initial = bac_spec_only(bac_100, p_100;\n                    optimizer=DiffEqFlux.ADAM(0.1),\n                    optimizer_options=(:maxiters => 10,),\n                    abstol = 1e-3, reltol=1e-3)\nlosses_100_initial = individual_losses(bac_100, p_100_initial)\nmedian(losses_100_initial)\nplot_callback(bac_100, p_100_initial, l, input_sample = samples)\n\n#= Now we can train the full system:\n=#\n@time   res_100 = DiffEqFlux.sciml_train(\n    bac_100,\n    p_100_initial,","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"DiffEqFlux.ADAM(0.5),","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"    DiffEqFlux.BFGS(initial_stepnorm = 0.01),\n    maxiters = 5,\n    cb = basic_bac_callback\n    )\n\n#= Continue improving it for 510 Steps with some plotting in between:=#\nfor i in 1:30\n    global res_100\n    res_100 = DiffEqFlux.sciml_train(\n        bac_100,\n        relu.(res_100.minimizer),\n        DiffEqFlux.ADAM(0.1),","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"DiffEqFlux.BFGS(initial_stepnorm = 0.01),","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"        maxiters = 5,\n        cb = basic_bac_callback\n        )\n    l = bac_100(res_100.minimizer);\n    plot_callback(bac_100, res_100.minimizer, l, input_sample = samples)\nend","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"","category":"page"},{"location":"generated/simple_graph_example/","page":"Simple graph example","title":"Simple graph example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Probabilistic-behavioural-control","page":"Home","title":"Probabilistic behavioural control","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A central problem of control theory is to make a system with a complex interior present a unified, aggregate behaviour towards the outside world. Further, the aggregate behaviour should be close to some specification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We approach this problem by giving a probabilistic notion of what it means to behave close to a specification. This probabilistic notion is based on defining what inputs a system typically encounters and defining a distance of the systems behaviour to the specified behaviour.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to make the above notions precise. We will consider systems and specifications given by parametrized input-output differential equations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign\n    mathcalS  dot x(t) = f(x(t)i(t)p)\n    o(t) = g(x(t)p) nonumber\n      nonumber p in mathcalP\nendalign","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x in X is system state, i in I is the input and o in O â€“- the output, typically mathbbR^n, and we fix a finite time interval T such that i(t) in mathcalB_i subset I^T. We assume a fixed initial condition x(0), and that both f and the function space mathcalB_i are chosen such that the solutions of \\eqref{eq:system} exist for all of T and are unique functions of the initial conditions. We denote such a system by mathcalS. Then the output o(t) depends only on p and i(t). The input and output are the interface between our system and the outside world. Willems behavioural point of view now suggests to not consider the ODE as the primary object of concern but to look instead at the set of possible input-output trajectories, collectively called the behaviour of the system \\cite{willems1989models, moor1999supervisory}. The specification then provides such a set of permissible trajectories, and if the input-output trajectories that can occur in the system are contained in this set, the system is said to satisfy the specification.","category":"page"}]
}
